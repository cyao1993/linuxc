#内核如何实现信号的捕捉
如果信号的处理动作是用户自定义函数,在信号递达时就调用这个函数,这称为捕捉信号.  
由于信号处理函数的代码是在用户空间的,处理过程比较复杂,举例如下:  

1. 用户程序注册了 SIGQUIT 信号的处理函数 sighandler.  
2. 当前正在执行 main 函数,这时发生中断或异常切换到内核态.  
3. 在中断处理完毕后要返回用户态的 main 函数之前检查到有信号 SIGQUIT 递达.  
4. 内核决定返回用户态后不是恢复 main 函数的上下文继续执行,而是执行 sighandler 函数,sighandler 和 main 函数使用不同的堆栈空间,它们之间不存在调用和被调用的关系,是两个独立的控制流程。  
5. sighandler 函数返回后自动执行特殊的系统调用 sigreturn 再次进入内核态。  
6. 如果没有新的信号要递达,这次再返回用户态就是恢复 main 函数的上下文继续执行了。  

如下图所示:

![kernel catch signal](./pngs/signal.png)


#使用二级指针巧妙删除链表节点
```c
/*
 * delete 的优化版本
 * 不需要对是否是删除头部特殊判断
 * 这里巧用了二级指针操作
 * 一个指向当前节点的二级指针就是其上一节点
 */
void delete_plus(struct node *p)
{
	struct node **pnext;

	for (pnext = &head; *pnext; pnext = &(*pnext)->next)
	{
		if (*pnext == p)
		{
			*pnext = p->next;
			return;
		}
	}
}
```

![delete](./pngs/delete.png)

#进程
+ 在各自独立的地址空间中运行
+ 共享数据需要mmap或者进程间通信机制

#线程
###需要在一个进程中同时执行多个控制流程就要用到线程
###进程里的信号处理函数也可以,只是线程更为灵活
###因为信号处理函数的控制流程只是在信号达到的时候产生
###在处理完信号后就结束,多线程的控制流程可以长期并存
###各线程之间共享的资源和环境:
+ 文件描述符表
+ 每种信号的处理方式(SIG_IGN、SIG_DFL 或者自定义的信号处理函数)
+ 当前工作目录
+ 用户 id 和组 id

##但有些资源是每个线程各有一份的:
+ 线程 id
+ 上下文,包括各种寄存器的值、程序计数器和栈指针
+ 栈空间
+ errno 变量
+ 信号屏蔽字
+ 调度优先级
